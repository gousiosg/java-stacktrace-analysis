\documentclass[conference]{IEEEtran}

\usepackage[pdftex]{graphicx}
\usepackage[cmex10]{amsmath}
\usepackage{algorithmic}
\usepackage{caption}
\usepackage{subfig}
\usepackage{url}
\usepackage{balance}

\begin{document}
%\title{ What GitHub and Google Code can tell us about the Causes of Crashes of Android Apps? }
%\title{ A Mining Study the Google Code can tell us about the Causes of Crashes of Android Apps? }

%\title{What can the Issues of GitHub and Google Code tell us about Exception Fragilities in Android? }

%\title{What can the Issues of GitHub and Google Code tell us about Exception Fragilities in Android? }

%\title{Results of a Mining Study on Exception Stack Traces embedded on issues of over 600 Android Projects}

\title{Unveiling Robustness Threats by Mining the Exception Stack Traces of over 600 Android Projects}

%\title{Discovering Threats to Robustness through Exception Stack Trace Analysis: Results of a Mining Study of Android Projects}

%\title{Discovering Threats to Robustness through Exception Stack Trace Mining}

%\title{Discovering Threats to Robustness through Exception Stack Trace Mining of over 600 Android Projects}

%\title{Discovering Threats to Robustness through a Mining Study of Exception Stack Traces}

%\title{Discovering Fragilities on the Exception-Related Code through  Exception Stack Trace Mining}

%\title{On the Common Characteristics Android-Apps Crashes: Results of a GitHub and Google Code Mining Study}

%\title{On the Common Characteristics of Android-Apps Crashes: Results of a GitHub and Google Code Mining Study}

%\title{On the Common Characteristics of Android Crashes: Results of a GitHub and Google Code Mining Study}


%\title{A first Glance on Characteristics of Android Crashes: Results of a GitHub and Google Code Mining Study}


%\title{A first Glance on Characteristics of Android Crashes: Results of a GitHub and Google Code Mining Study}


\author{\IEEEauthorblockN{Roberta Coelho\IEEEauthorrefmark{1},
Lucas Almeida\IEEEauthorrefmark{1},
Georgios Gousios\IEEEauthorrefmark{2}, 
Arie van Deursen\IEEEauthorrefmark{2}
}
\IEEEauthorblockA{\IEEEauthorrefmark{1}Federal University of Rio Grande do Norte\\
Natal, Brazil\\
Email: \texttt{roberta@dimap.ufrn.br,lucas.almeida@ppgsc.ufrn.br}}
\IEEEauthorblockA{\IEEEauthorrefmark{2}Delft University of Technology\\
Delft, The Netherlands\\
Email: \texttt{\{g.gousios,arie.vandeursen\}@tudelft.nl}}
}

\newcommand{\todo}[1]{\textbf{TODO}\footnote{\textbf{TODO:} #1}}

% make the title area
\maketitle

%GitHub 31,592
% Google Code: 127,456
%All: 159,048
% bf: 31,592 (with exception)



%The goal of this study was to: identify common characteristics 
%of such traces and investigate the fragilities on the exception-related code that can be revealed
%from them. 
%The goal of this study was to: identify common characteristics 
%of such traces and investigate the whether they can reveal
%the characteristics on the source code that may be favoring the introduction of faults 
%(i.e. Uncaught Exceptions, and Unintened handler Actions), and consequently
%decreasing the program robustness.
%(of apps or the underlaying framework) 



\begin{abstract}
The number of mobile apps is increasing in a daily rate. If on the one hand they
extend phones capabilities far beyond of the basic calls, on the other hand they have to 
cope with an increasing number of exceptional conditions 
(e.g., faults in underlying middleware or hardware; memory and battery restrictions). 
Therefore, mechanisms for exception detection and handling are not an optional add-on but a 
fundamental part of such apps. However, studies have shown that such mechanisms are the less 
understood and tested parts of the system. As a consequence they may affect the system the 
other way around, making the system even less robust, leading to failures such as uncaught exceptions 
and unintended handling (i.e., exceptions being mistakenly caught by existing handlers).
This paper reports a study which mined the stack traces embedded on 
159,048 issues reported on Android projects hosted in GitHub (482 projs.) 
and Google Code (157 projs.). 
The goal of this study was to: investigate the whether the exception stack traces
 can reveal common characteristics on the exception-related code that
may be favoring the introduction of the aforementioned failures, which would be responsible for 
decreasing the application robustness. We call such characteristics ``fragilities" of the exception-related code.
Overall 6,005 exception stack traces were extracted, and analyzed in 
combination with source code and bytecode analysis. 
Some fragilities consistently detected in this study include: 
(1) undocumented runtime exceptions thrown by third party code;
(2) undocumented checked exceptions thrown by a JNI interface function;
(3) unexpected exception wrappings (e.g., Errors being wrapped in checked exceptions),
revealing that Java hybrid exception model is not fully used according to its purpose.
Moreover, about 50\% of all analyzed projects reported at least one NullPointerExeption
as the root cause of an exception stack trace.
This study provides insights on such fragilities and the robustness threats  
they impose not only to Android apps but also to other systems 
based on Java exception model.

\end{abstract}

%GitHub 31,592
% Google Code: 127,456
%All: 159,048



%\IEEEpeerreviewmaketitle

%Such increase is motivated by pervasiveness of the World Wide Web 
%and the unprecedented increase of global smartphone shipments -
%the mobile industry shipped over 315 million smartphones in the last quarter of 2013 ~\cite{googleio}.

%In this context, Android has become a leading platform - thanks to its open-source 
%model and hardware partners like Samsung, HTC, Motorola, Asus (besides Nexus Google's
% own device) ~\cite{gartner}.  Google estimates that there is over 1 billion Android active users per month ~\cite{googleio},
%and the number of apps built on top of Android increases in a daily rate.

%Our conjecture is that several Android applications may be suffering from common 
%fragilities on the exception-related code (of the applications themselves or 
%the underlaying platform) which may be degratind their robustness.
%We call ``fragilities" characteristics on the exception-related code that favor the introduction
%of aforementioned failures.

%In Java, when an application fails due to an uncaught exception, 
%it automatically terminates, while the system prints a stack trace to the console, 
%or log file ~\cite{gosling2000java}.  A typical Java stack trace consists of  the fully qualified name 
%the thrown exception and the ordered list of methods that were active on the call stack before 
%such exception has occurred ~\cite{gosling2000java,bloch2008effective}.
%and unintended handling~\cite{miller1997issues} (i.e., exceptions being mistakenly caught by existing handlers) 

\section{Introduction}

Along the recent years, we have witnessed an astonishing increase in the number of
mobile applications. If on the one hand such applications extend phones capabilities 
far beyond of the basic calls and textual messages, on the other hand
they have to face an increasing number of threats to application robustness
 arising from: faults on underlying middleware and hardware (e.g., GPS receiver, camera, sensors);
faults on third party services and libraries; compatibility issues ~\cite{McDon13}; 
 memory and battery restrictions~\cite{Zhang12}; among others. 

Therefore, techniques for error detection and handling are not  an optional add-on but a 
fundamental part of such apps. The exception handling mechanism ~\cite{goodenough1975exception},
embedded in many mainstream programming languages, such as Java, C++ and C\#,
 is one of the most used techniques for detecting and recovering from such exceptional conditions. 
Android, the leading plaform for mobile applications~\cite{gartner} (thanks to its open-source 
model and hardware partners like Samsung, HTC, Motorola, Asus besides Nexus Google's
 own device)  reuses the embedded Java exception model to detect and handle 
 exceptional conditions.

Studies have shown, however, that the exception-related code is generally poorly understood and the
 less tested parts of the system~\cite{miller1997issues,Robil00,shah2010understanding, 
garcia2007extracting,garcia2001comparative,cabral2007exception,coelho2011unveiling}.
As a consequence they may affect the system the other way around.
The exception-related code may favor the introduction of failures such as 
uncaught exceptions~\cite{jo2004uncaught, zhang2012amplifying} - 
which can lead to system crashes, making the system even less robust~\cite{coelho2011unveiling}.

In Java, when an application fails due to an uncaught exception, 
it automatically terminates, while the system prints a stack trace to the console, 
or log file ~\cite{gosling2000java}.  A typical Java stack trace consists of  the fully qualified name 
the thrown exception and the ordered list of methods that were active on the call stack before 
such exception has occurred ~\cite{gosling2000java,bloch2008effective}.

Until recent years, the availability of data, reporting such failures, was scarce. 
It comprised only few large scale projects (e.g. the Mozilla crash report dataset\footnote{https://code.google.com/p/promisedata/issues/detail?id=88}).
Recently we have observed a rapid increase in the number of open
source projects that make their version control systems as well as the issue tracking systems
publicly available in repository hosting sites such as GitHub and Google Code.
Developers and users of open-source projects uses such provided
 infra-strucute to share information (e.g., exception stack traces~\cite{bettenburg2008makes,schroter2010stack}) across 
the software development.

%When available, the exception stack traces provide a useful source of information about system crashes ~\cite{bettenburg2008makes} which 
% can enable different kinds of post-mortem analysis and support:  debugging~\cite{schroter2010stack}, 
% bug classification and clustering~\cite{wang2013improving, kim2011crash, dhaliwal2011classifying},  
%automated bug fixing~\cite{sinha2009fault} and fault-proneness prediction models~\cite{kim2013predicting}. 

This study performs a post mortem analysis of the exception stack traces embedded on issues
reported on Android projects hosted in GitHub and Google Code. 
The goal of this study was to: investigate whether the reported exception stack traces
 can reveal common fragilities on the exception-related code.  
We call ``fragilities" characteristics on the exception-related code 
that favor the introduction of failures such as uncaught 
exceptions -  contributing to decrease the applicaiton robustness.
To guide this investigation we compiled general guidelines on how to use
exceptions proposed by Gosling~\cite{gosling2000java},
Wirfs-Brock~\cite{wirfs2006toward} and Bloch~\cite{bloch2008effective}.
Then, using a custom tool called ExceptionMiner,
 which we develop specifically for this study, we mine stack traces from the issues reported 
on 482 Android projects hosted in GitHub and 157 projects hosted in Google Code.
Overall 159,048 issues were analyzed and 6,005 stack traces were extracted from them.
The exception stack trace analysis was augmented with additional information
extracted from JDK, Android Plaform and the applications using byte code 
and source code analysis. Manual inspection was used to leverage the understanding 
of exception stack traces and support further discussions and insights.

Some outcomes consistently detected during this study were the following:

\begin{itemize}

 \item  A multitude of programming mistakes were reported as the main causes of exception stack traces:
 27,71\% of the analyzed exception stack traces reported a java.lang.NullPointerException the root cause;
and  51,96\% of all projects reported at least one exception stack trace on which the NullPoiterException
was the root cause.

   \item  Cross-type exception wrappings (e.g., an OutOfMemoryError wrapped in a checked exception)
were detected on stack traces. Indicating that the purpose of Java's hybrid exception model may not have been adequately used.

   \item Undocumented runtime exceptions signaled by third-party code (i.e., libraries and Android platform). 
    In this study, none of the third-party methods explicitly signaling runtime exceptions included such exceptions
    on ``exception specifications" (i.e., a list of exceptions that a method might raise during its execution). 

   \item Undocumented checked exception signaled by a  JNI interface function defined on Android Platform. 
    Some flows reported a checked exception thown by a JNI interface function, and  such exception was not  
    part of the ``exception interface" of JNI function nor the methods on its invokation chain - it can lead to 
   uncaught exceptions that are difficult to debug. 

\end{itemize}

Such outcomes point to threats not only to the developement of robust Android apps, 
but also to the developement of any robust Java-based system. For instance, in the absence of the 
``exception specification" of  a third-party code, it is difficult or 
even enfeasible for the developer to protect the code against ``unforeseen" exceptions. 
Since, in such cases the client usually do not have access to the source code, the undocumented exceptions may 
remain uncaught and lead to system crashes. Moreover, the cross-type exception wrappings 
(e.g., OutOfMemoryError is wrapped in a checked Exception) 
may lead to unintended handling problems - trying to handle an instance of OutOfMemoryError ``hiden" in 
a checked exception may lead the program to an unpredictable state.

Hence, the study results are relevant to Android and 
Java developers who may underestimate how likely are the
 exceptions related to programming mistakes, and how 
 tricky it can be to prevent the uncaught exceptions from third-party code
 in the absence of ``exception interfaces". Moreover, results are relevant to 
designers of languages and tools to consider ways of reducing such fragilities 
in Android and Java environments.

The remaining of this paper is organized as follows. Section 2 presents a
background on Android Platform and Java exception model. 
Section 3 presents the study design. Section 4 reports the study findings. 
Section 5 provides further discussions and insights.
Section 6 presents the threats to validity associated to this study. Finally Section
7 describes the related work, and Section 8 concludes the paper and outlines
directions for future work.

\section{Background}
\label{sec:back}

\subsection{The Android Platform} \label{sec:extypes}
Android is an open source platform for mobile devices based on Linux kernel,
which also comprises a subset of the core Java library, a set of third-party libraries (e.g.  SQLite),
the Dalvik runtime environment, and the Application Framework (which provides 
higher-level services to the applications running on the platform) ~\cite{andguide}.

%The Android platform is mostly implemented in Java and uses Java Native Invocation (JNI) to access native C/C++ code. 
%And as mentioned before, it reuses the embedded Java Exception model to detect and handle 
%abnormal computation states.

The Android Application Framework supports an event-driven development model. 
Among the basic elements that comprise an Android application, we can cite the
 Activity class. The Activity is the main class of an Android app (there is usualy one
Activity per application window). Each Activity defines a set of hook methods  
(e.g., OnCreate(), onPause()) that are dispatched automatically by the Android 
framework (by inversion of control), in response to infrastructure and application events.

The Android Application Framework also provides several supporting APIs, such as 
the APIs to support concurrent development (e.g. AsyncTask). 
Such APIs particularly useful due to the high demand for responsiveness 
in mobile environment (mobile apps can easily become 
unresponsive due to resource limitation and excessive network access).


%\begin{figure} \centering \includegraphics[scale=0.8]{arch3.png}
%  \caption{Android Architecture} \label{fig:exchier} \end{figure}

\subsection{Exception Model in Java} \label{sec:extypes}

In Java, an exception is represented according to the class hierarchy shown in
Figure~\ref{fig:exchier}.  According to it every exception is an
instance of the Throwable class, and can be of three kinds: the checked exceptions
(extends Exception), the runtime exceptions (extends RuntimeException) and errors
(extends Error)~\cite{gosling2000java}. The checked exception received such name
 because they must be declared on the method's exception interface (i.e., a list of exceptions that a method 
might raise during its execution) and the compiler statically checks if
 appropriate handlers are provided within the system.
Both runtime exceptions and errors are also known as unchecked exceptions, because 
they do not need to be specified on method exception interface and do not trigger any 
compile time checking.

By convention an Error represents an unrecoverable condition which usually results
from failures detected by the Java Virtual Machine, such as OutOfMemoryError and
normally should not be handled inside the application. The user-defined exceptions 
can be either checked or runtime. The Java specification~\cite{gosling2000java} 
suggests that user-defined exceptions should be checked (because doing so 
the callers of a method will know about the exceptions that a method can throw and so 
they can decide what to do about them). However, runtime exceptions can also be 
used to represent user-defined exceptional conditions.In fact, there is a long-lasting debate 
about the pros and cons of both approaches~\cite{javatut,stackoverlow,debate},
\footnote{152 questions in Stackoverlow are related to this debate}.


\begin{figure} \centering \includegraphics[width=\hsize]{new2_hierarchy.png}
  \caption{Exception Hierarchy in Java} \label{fig:exchier} \end{figure}


Besides, the runtime exceptions are also implicitly thrown by the runtime environment when a program violates 
the semantic constraints of the Java programming language (e.g., out-of-bounds array index, divide-by-zero 
error, null pointer references).\footnote{Some programming languages react to such errors by peremptorily terminating the program; 
other programming languages allow similar approaches e.g.C\#; and others let the program to continue
 its execution in some situations such as the out-of-bounds array index e.g., C++. }  
The programs are not expected to handle such runtime exceptions signaled by the runtime environment ~\cite{gosling2000java}. 

%In Java an exception can be thrown in one of the following
%circumstances~\cite{gosling2000java}: 
%(i) explicitly thrown when a throw statement is executed; 
%(ii) implicitly thrown by the JVM when the evaluation of an expression
% violates the normal semantics of language, also referred as a coding error
% (e.g., out-of-bounds array index, division-by-zero, access to a null reference); or 
%(iii) implicitly thrown by the JVM due to an internal error or resource limitation (e.g.,
%OutofMemoryError). 
%\todo{This sub-section is quite similar to the section introduction, shouldn't
%we merge them?}

%When an exception is thrown, it causes a transfer of control from the point
%where the exception occurred to a point that can be specified by the programmer
%(exception handler) - in Java it is represented by the try-catch block .

In Java, once an exception is thrown, the runtime environment looks for the nearest enclosing exception handler
(in Java it is represented by the try-catch block), and unwinds the execution stack if necessary.
 Looking for the handler on the invocation stack is claimed to increase software reusability, 
since the invoker of an operation can handle it in a wider context ~\cite{miller1997issues}.

 A common way of  propagating exceptions in Java programs is through exception wrapping
 (also known as exception chaining). Exception wrapping allows one exception 
to be wrapped in another one and re-thrown. Figure~\ref{fig:wrapping} shows 
an exception stack trace which illustrates an exception wrapping. 
For simplicity we will refer to exception stack trace as stack trace along the text.
The bottom part of the stack trace is the \emph{root exception}, which indicates
the first reason (root cause) for the exception be thrown (in this case, the computer run out of
memory). The top part of the stack trace indicates the location of the exception
manifestation (which will call \emph{exception wrapper} along this paper). The
execution flow  between the root exception and the wrapper may
include other intermediate exception wrappers. In all levels, the exception
\emph{signaler}, is the method that threw the exception, represented on the
stack trace as the first method call below the exception declaration.

\begin{figure} \centering \includegraphics[scale=0.6]{stacktrace_bw.png}
\caption{Example of an exception stack trace in Java.}
\label{fig:wrapping}
\end{figure}

%<AVALIAR MOVER ESTE STACK TRACES PARA UMA FIGURA QUE MOSTR COMO ELE É QUEBRADO...
%PELO EXCEPTION MINER E AS INFORMAÇÕES VAO PARA O BANCO...>

% \subsection{Public Project Repositories and Issue Trackers} 
% ONE OF THE REVIEWERS COMPLAINED ABOUT THE ABSENCE OF EXPLANATIONS OF WHAT AN ISSU IS...
% As mentioned before, currently more and more projects are becoming available in 
% public project repositories such as GitHub and Google Code.
% Such repositories provides facilities such as....
% The issue trackers available in such projects ....

\subsection{Best Practices}
\label{sec:best}

Several general guidelines have been proposed on how to use Java
exceptions~\cite{mandrioli1992advances,gosling2000java,wirfs2006toward,
bloch2008effective}. Such guidelines do not focus on 
advocating any specific exception type, but rather propose ways to effectively use each of them.
 We compiled a list of the guidelines related to exception types in Java, 
summarized below:\footnote{We also compiled guidelines related
to exception handling but they are out of the scope of this paper.}

%\noindent\emph{Meaning of Exception Types}

%\textbf{I
\emph{I-Checked exceptions should be used to represent recoverable
conditions} (\cite{mandrioli1992advances,gosling2000java,wirfs2006toward,bloch2008effective})
The developer should use checked exceptions for conditions from which the caller
is expected to recover. By confronting the API user with a checked exception,
the API designer is forcing the client to handle the exceptional condition. The
client can explicitly ignore the exception (swallowing, or converting it to
other type) at the expense of the program's robustness~\cite{gosling2000java}.

\emph{II-Error represents an unrecoverable conditions which should not he handled} 
(\cite{gosling2000java}).  Errors should result from failures detected
by the runtime environemt which indicate resource deficiencies, invariant
failures or other conditions, that make impossible for the program to recover.

%\noindent\emph{Exception Throwing}

\emph{III-A method should throw exceptions that precisely define the
exceptional condition} (\cite{gosling2000java,bloch2008effective}). To do so,
developers should either try to reuse the exception types already defined in the
Java API or they should create a specific exception. Throwing general types such as a
pure java.lang.Exception or a java.lang.RuntimeException is considered a bad practice.

%\textbf{IV-Do not repeatedly re-throw exceptions, handle exceptions as close as
%possible to the problem}~\cite{wirfs2006toward}. 
%Programs that frequently throw exceptions lose in performance ~\cite{wirfs2006toward,gosling2000java}.
%Moreover, 
%Close to the place that the exception was throw the caller usually has
%enough contextual information to perform  corrective actions. When the exception
%is propagated far away from the method where it was signaled (i.e. further away
%#from the problem) it can be difficult to take meaningful recovery actions.
%*~\todo{RSC:this practice was not well explored, can be removed if we need space.}

%\noindent\emph{Exception Documentation}
%\textbf{IV- It is wise to document all exceptions thrown by a method} 

\emph{IV- All exceptions explicitly thrown by a library/framework reusable code should be documented.}
(\cite{mandrioli1992advances,gosling2000java,wirfs2006toward,bloch2008effective}).
The exceptions thrown by a method are an important part of methods interface,
and is required to use the method properly. The checked exceptions are already
part of the  methods signature, and the method caller is aware of the checked
exceptions being thrown by it. According to~\cite{bloch2008effective}, it is
also wise to document the explicitly thrown runtime exceptions\footnote{This
excludes the implicitly signaled runtime exceptions related to programming
mistakes} as carefully as checked exceptions, specialy when developing
 library/framework reusable code. Doing so, the clients of such ibrary/framework
will be aware of all the exceptions a method can throw and can design the code
to deal with them ~\cite{Robil00}. 

If the developer fails to do follow such practices (specially when developing 
utility code) it will be difficult or even impossible for the caller to 
make effective use of such method~\cite{wirfs2006toward, bloch2008effective},
and protect the system against unforeseen exceptions thrown by the utility code,
which can lead to the uncaught exceptions - one of the main causes of 
systems crashes. These best practices guided our exploratory study dscribed next.


%Next section discusses the
%study procedure and the practices' misuses that emerged from this study.

%This study focus on the analysis of crash information (related to uncaught exceptions) of a family of Android applications
%aiming at  extracting their common characteristics and looking for similar vulnerabilities on applications and underlaying platform.
%In Java when an application crashes due to an uncaught exception ... 
%Exception Stach trace is usually (procurar por artigo).

%To answer this question we selected 
%The goal of this exploratory mining study was to extract exception stack traces embedded on issues of Android projects 
%(hosted in GitHub and Google Code), looking for its \emph{common characteristics} and investigating whether
% they could reveal \emph{common fragilities} on the exception code of both the applications and the underlaying  framework. 
%Our study focused on open-source apps, since the information needed to perform our study
%cannot be retrieved from commercial apps, whose issue report systems and 
%source codes are not publicly available. The Android open-source apps were also 
%target of other research studies ~\cite{Linar13,ahimed}.   

%extract exception stack traces embedded on issues of Android projects 
%(hosted in GitHub and Google Code), looking for its \emph{common characteristics} and investigating whether
% they could reveal \emph{common fragilities} on the exception code of both the applications and the underlaying  framework. 
%Our study focused on open-source apps, since the information needed to perform our study
%cannot be retrieved from commercial apps, whose issue report systems and 
%source codes are not publicly available. The Android open-source apps were also 
%target of other research studies ~\cite{Linar13,ahimed}.   

\section{Study Design}
\label{sec:study}

%This section describes the exploratory study whose goal was to investigate:
%\begin{description}
 % \item[RQ] \noindent\emph{Which fragilities on the exception-related code can be revealed from a post morten exception stack trace analysis of Android projects?} 
 %    \item
%\end{description}
%One major decision that had to be made for our investigation was the selection of the target 
%projects. We have selected a set of XXX open-source Android projects hosted in GitHub and 
%Google Code. GitHub and Google Code are among the most used hosting sites for open-source
 %projects,

The goal of this exploratory mining study was to investigate whether the exception stack traces 
embedded on issues of Android projects (hosted in GitHub and Google Code), can reveal 
\emph{common fragilities} on the exception code of both the applications and the underlaying  framework. 
Our study focused on open-source apps, since the information needed to perform our study
cannot be retrieved from commercial apps, whose issue report systems and 
source codes are not publicly available. The Android open-source apps were also 
target of other research studies ~\cite{Linar13,ahimed}.   

This exploration is guided by the set of best practices compiled in this study; we investigate whether characteristics 
of exception stack traces can pinpoint best practices violations. As mentioned before, 
call ``fragilities" characteristics on the exception-related code that favor the introduction
of failures such as uncaught exceptions and unintended handling. 

To support this investigation, we developed a tool called ExceptionMiner (see Section ~\ref{sec:exceptionminer})
which extracts the exception stack traces embeeded on issues, 
and combines stack trace information with source code and bytecode 
analysis. Such combination was needed to enable the identification of 
fragilities on the exception-related code.
Moreover, manual inspections were also used to leverage
 the understanding of stack traces and support further discussions and insights.
In this study we explore the domain quantitatively and highlight interesting cases by 
exploring cases qualitatively.  

\subsection{Data Extraction Process}
\label{sec:miningproc}

In this exploratory study the following information is needed: (i) the issues reported on Android project hosted on 
GitHub and Google Code; (ii) the stack traces embedded on these issues; (iii) the type of the exceptions
 reported on the stack traces (e.g., error, runtime, checked); (iv) the origin of such exceptions 
(e.g., the application, a library, the Android platform). Next, we describe: how such information 
was retrieved from GitHub and Google Code; how the exceptions stack traces were extracted and distilled,
 and how the type associated to each exception and its origins was identified, and finally how manual
inspections supported this work.

%mentioned 
%The data used in our study to answer our research questions are: the issues related to each 
%Android project available in each repository; the source code and manifest file of each application;
%the bytecode of all exceptions defined and reused by Android platform.

\subsubsection{Android Apps in GitHub}
\label{sec:git}

%As mentioned before, this study mined information available on GitHub issues,
%more specifically, extracting and distilling the stack traces embedded on GItHub issues. 

This study used the dataset provided by the GHTorrent project~\cite{Gousi13}, 
an off-line mirror of the data  offered through the Github API.  
To identify Android projects, we performed a case insensitive search for the
term \textsf{android} in the repository's names and short descriptions.  
Up to 23 Feb 2014,  when we queried GHTorrent, such heuristic could
 find 2.542 repositories. Running the ExceptionMiner tool (described next)
 in this set we observed that 589 apps had at least one issue containing a stack trace.

Then we performed further cleanup, inspecting the site of every Android
reporting at least one stack trace, to make sure that they represented real
mobile apps. During this clean up 106 apps were removed because they were either
example projects (i.e., toy projects) or tools to support Android development
(e.g. Selendroid, Roboeletric - tools to support the testing of Android apps).
The filtered set consisted of 482 apps. This set of 482 projects contained overall 31,592 issues from which 4,042 exception stack traces 
were extracted. Issues on Github are different from issues on dedicated bug tracking tools such as 
Bugzilla and Jira. The most important difference is that there are no predefined fields
  (e.g. severity and priority). Instead, Github uses a more open ended tagging system, on which
repositories are offered a pre-defined set of labels, but repository owners can modify 
them at will. Therefore, an issue may have none ore an arbitrary set of labels depending 
on which repository it was created. Table ~\ref{tab:lables} illustrates the ocurrences of different lables 
on the issues including exception stack traces.


% \centering
%  \begin{tabular}{|p{2cm}| p{5cm}|}
%    \hline

\begin{table}
  \centering
  \begin{tabular}{lr|lr}
    \hline
     \multicolumn{2}{c}{\bfseries{GitHub}} &  \multicolumn{2}{c}{\bfseries{Google Code}} \\
      \bfseries{Lable} &  \bfseries{\% Occurrences} &  \bfseries{Lable} &  \bfseries{\% Occurrences} \\
    \hline
empty &	54,24\% & Defect &	91,96\% \\
Defect &	39,56\%  & Enhancement  &	3,16\% \\
Enhancement &	0,57\% & Task	& 1,37\% \\
Support &	0,52\% & empty &	1,12\% \\
Problem &	0,36\% & StackTrace &	0,70\% \\
Others &	4,74\% &  Others &	1,68\% \\   
  \hline
  \end{tabular}
  \caption{Lables on issues including exception stack traces.}
  \label{tab:lables}
\end{table}

Based on the assumption that regardless the issue type, every exception stack
trace contains relevant information concerning the exception structure of the
projects analyzed - and therefore can review fragilities on the exception-related code -  
we opted for not restricting the analysis only on defect
issues\footnote{We conducted the same analysis on the defect issues and the top
exceptions are similar to the ones mentioned on defect issues. Due to space
limitation we limit to present the general analysis here. More detailed analysis
on the defect issues can be found at:
\url{https://github.com/souzacoelho/exceptionminer}}.
 Moreover, issues and pull requests are dual on Github; all pull requests have a corresponding 
``backing'' issue which are automatically generated. Therefore, we excluded such automatically generated
issues from our analysis. 

\subsubsection{Android Apps in Google Code}
Google Code contains largely used open-source Android apps (e.g. K9Mail \footnote{K9Mail moved to Github but as a way of not loosing the project history 
it advices their users to report bugs on Google Code issue tracker.}), however, differently from GitHub, Google Code does not provide an API to access the information related
 to hosted projects \footnote{Google code used to provided a Web service to such repository, but it was deactivated in June 2013 what Google called a "clean-up action".}.
To overcome this limitation we needed to implement a Web Crawler (incorporated in ExceptionMiner tool described next) that navigated 
through the web interface of Google Code projects extracting all issues and issue comments and storing in a relational database for later analysis.

To identify Android projects in Google Code, we performed a similar heuristic: we performed a case insensitive search 
(on Google Code search interface) for the term ``android". On January 2014, when we queried Google Code, such heuristic could
 returned a list of 788  projects. This list comprised the seeds sent to our Crawler.

From this set, 724 defined at least 1 issue. Running the ExceptionMiner tool (described next)
 in this set we observed that 183 apps had at least one issue containing an exception stack trace.
 Then we performed further cleanup (similar to the one described previously) inspecting the site 
of each project. As a result we could identify 157 Android projects.  This set contained overall 127,456 issues,
 from which 1,963 exception stack traces were extracted. Table ~\ref{tab:lables} illustrates the ocurrences of different lables 
on the issues including exception stack traces. Differently from GitHib, in Google Code most of 
the issues were labled as ``Defect". However, based on the same assumption described for the GitHub repository
 we considered all issues reporting stacks (regardless its lables).

%SELECT distinct(type), count(*) as n
%  FROM exceptionalissue where repo !='android' group by type order by n desc;

%For instance: K9mail  was hosted in Google Code 
%before moving to GitHub and in order not to loose the project history it advices their 
%users to create issues on Google Code as a way to preserve project history.

%To overcome this limitation and mine the information available on such Google Code 
%projects we implemented a Web crawler which navigated (incorporated in ExceptionMiner tool described next) 
% on each project and issue page, extracting the content of each issue to store on relational database.

%{MOSTRAR UMA FIGURA COM TODOS OS PASSOS E RESSALTAR OS PASSOS MANUAIS}
%COMPLETE HERE.....
%\subsubsection{Database of Exception Stack Trace Information}
%\subsubsection{Distiling Exception Stack Trace Information}
%\subsection{Process}
%ESPALHAR ESTA SECAO NAS OUTRAS.
%Figure~\ref{fig:overviewfig} presents an overview of the mixed-methods approach
%conducted to answer these questions. The mixed-methods approach is composed by the following steps:

\section{The ExceptionMiner Tool}
\label{sec:exceptionminer}

The ExceptionMiner is modular mining tool which is able to connect to issue repositories, 
extract issues, mine stack traces from them, distill exception stack trace information,
and enable the execution of different analyses by combining exception stack 
trace information with bytecode and sourcecode analysis. The main components of ExceptionMiner are as follows:

\emph{\textbf{Repository Connectors.}} This component enables the connection 
with issue repositories. In this study two main connectors were created: one which connects to 
GHTorrent database, and Google Code connector which is comprised of a Web Crawler,
 that can traverse Google Code Web interface and extract the project issues. 
Projects matadata and the issues associated to them are stored on a relational 
database by this components.

\emph{\textbf{Exception Stack Trace Distiller.}}
This component distills the information that composes a stack trace.
 Some of the attributes extracted from the stack trace are:
 the root exception and its signaler, the exception wrappers and their corresponding signalers. 
This component also distills fine grained information of each attribute such as: the classes and packages associated to them.
This component is based on a combination between a regular expression based parser 
with heuristics able to identify and filter exception names and stack traces inline with text. 
In contrast to existing issue parsing solutions such as Infozilla, the parser
created in this work: (i) can discover stack traces inlined with logs files \footnote{In several 
exception stack traces, the exception frames were preceeded by logging information e.g., 
"03-01 15:55:01.609 (7924): at android.app.ActivityThread.access\$600(ActivityThread.java:127) 
"which could not be detected by existing tools.)}.

%\begin{tiny}
%\begin{verbatim}

%03-01 W/dalvikvm(7924): threadid=1: thread exiting with uncaught exception (group=0x40adf210)
%03-01 15:55:01.609 (7924): FATAL EXCEPTION: main
%03-01  (7924): java.lang.RuntimeException: ...
%E/AndroidRuntime( 7924):  at android....performLaunchActivity(ActivityThread.java:1967)
%03-01 15:55:01.609 (7924):  at android....handleLaunchActivity(ActivityThread.java:1992)
%03-01 15:55:01.609:  at android.app.ActivityThread.access\$600(ActivityThread.java:127)
%E/AndroidRuntime( 7924):  at android....handleMessage(ActivityThread.java:1158)
%\end{verbatim}
%\end{tiny}

As mentioned before, the tool enables a set of exception stack traces analyses by combining exception stack 
trace information with bytecode and sourcecode analysis. Each analysis is implemented as a different module 
on ExceptionMiner. Next, we present core analyses which were implemente on ExceptionMiner. Such analyses 
provide aditional information to be used on further analyses described in Section ~\ref{sec:result}:

\emph{\textbf{Exception Type Analysis.}} To support a deeper investigation of the 
stack traces every exception defined on a stack trace need to be classified according to its type
(e.g. Error, Exception or RuntimeException). The module responsible for this analysis 
uses Design Wizard~\cite{Brunet09} framework to inspect the bytecode of all exceptions reported on issues.
The nidyke walks up the type hierarchy of a Java exception until it reaches a base exception type.
This module analyzed the exception hierarchy of all exceptions defined on:
Android Platform (API level 19) - which includes all basic Java exceptions that 
can be thrown during the app execution. The exceptions thrown inside the apps
were classified using manual inspections as well as the exceptions thrown only
on previous versions of the Android platform.

\emph{\textbf{Exception Signaler Analysis.}}
This module is responsible for classifying each signaler according 
to its origin (i.e. Android Application Framework, Android Libcore, Application, Library). 
Table~\ref{tab:signalers} presents the heuristic adopted in this classification.
To enable such classification, we needed to feed this module the information
comprising all Java packages that compose: the Android Plaform;
 the Android Libcore; and each analyzed Application. 
To discover the packages composing the first two origins
we could reffer to the Android Specification.
To discover the packages composing each application, this module 
extracted the manifest files of each Android app
 - which defines the main packages that compose the applications.
 Whenever this file was not available, we recursevely analyzed the 
structure of source-code directories composing the app
- filtering out the cases on which the application 
also included the source-code of reused libraries.
Then based on this information and using pattern matching 
between the signaler name and the packages this module identifies 
the origin of the exception signalers. The exceptions were considered
 from libraries if their packages were not defined 
on Android Platform, core libraries nor on applications.
Table ~\ref{signalers} summarizes the signaler classification.

%\noindent\emph{Exception Wrapping Analysis.} 
%\noindent\emph{Concern Mapping.} 

\begin{table}
  \centering
  \begin{tabular}{rp{29em}}
    \hline
    \bfseries{Signaler} & \bfseries{Description} \\
    \hline
    \bfseries{android} & If the exception is thrown on a method defined in Android Platform.\\
    \bfseries{app}     & If the exception is thrown on an application method.\\
    \bfseries{libcore} & If the exception is thrown on one of the core libraries reused by Android (i.e., org.apache.harmony, org.w3c.dom, sun.misc, org.apache.http, org.json, org.xml). \\
    \bfseries{lib}     & If the exception is thrown on a method that was not defined by any of the elements above.\\
    \hline
  \end{tabular}
  \caption{Sources of exceptions in Android}
  \label{tab:signalers}
\end{table}

\subsection{Manual Inspections}
In the context of the ExceptionMiner tool, manual inspections were used:
to help on the identification of packages composing the Android platform, 
libs and apps analyzed in this study (as described previously); and to 
identify the type of some exceptions reported on issues, 
that could not be automatically identified by the ExceptionMiner tool.
Some exceptions could not be automaticaly identified because they were 
not defined on the last version of the application (the one analyzed by ExceptionMiner),
or were defined on libraries not found among application resources.
In such cases we manually inspect the sourcecode or javadoc
 documentation available online of each of them. 
When the exception was not found on the previous versions, the exception where classified 
in our study as "Undefined".  Only 31 exceptions 
remained undefined - such exceptions were reported on 61 exception stack traces as 
presented in Table ~\ref{tab:typeroottab}.

\subsection{Replication Package}
All the data used in this study will be publicly available at https://github.com/souzacoelho/exceptionminer
Specifically we provide: (i) all issues related to Android projects found
in GITHub and Google Code used in this study; (iii) all stack traces extracted
from issues (ii) the results of manual inspection steps; (iv) the tool developed 
in this work to support stack trace extraction and distilling.

\section{The Study Results}
\label{sec:result}

This section presents the results of the study, providing both a
quantitative and qualitative analysis of the outcomes. The structure of this section
 is centered on questions that guied the search for fragilities (on the exception-related code)
based on exception stack trace information.

\subsection{What can the Common Root Exceptions tell us? }

After distilling the information available on the exception stack traces we could find 
the the exceptions commonly reported as the root causes of stack traces.
Table \ref{tab:topten} presents a list the top 10 root exceptions found in the study - 
 ranked by the number of distinct projects on which they were reported. 
The table shows how many times the signaler of such exception was a method defined on
the Android Platform, the Android libcore, the application itself or a third-party library -
 following the classification as presented in Table  \ref{tab:signalers}. 

\begin{table*}
  \centering
  \begin{tabular}{rcccccccc}
    \hline
    \bfseries{Root Exception} &  \multicolumn{2}{c}{\bfseries{Projects}} &  \multicolumn{2}{c}{\bfseries{Occurrences}} & \textsf{Android} & \textsf{Libcore} & \textsf{App} & \textsf{Lib} \\
    & \bfseries{\#} &  \bfseries{\%} & \bfseries{\# } & \bfseries{\% } &&&&\\
    \hline

java.lang.NullPointerException	&	332	&	51,96\%	&	1664	&	27,71\%	&	525	&	20	&	836	&	280	\\
java.lang.IllegalStateException	&	120	&	18,78\%	&	278	&	4,63\%	&	185	&	31	&	41	&	39	\\
java.lang.IllegalArgumentException	&	142	&	22,22\%	&	353	&	5,88\%	&	195	&	12	&	95	&	44	\\
java.lang.RuntimeException	&	122	&	19,09\%	&	319	&	5,31\%	&	203	&	2	&	64	&	51	\\
java.lang.OutOfMemoryError	&	78	&	12,21\%	&	237	&	3,95\%	&	141	&	16	&	35	&	34	\\
java.lang.NoClassDefFoundError	&	67	&	10,49\%	&	94	&	1,57\%	&	10	&	0	&	46	&	37	\\
java.lang.ClassCastException	&	64	&	10,02\%	&	130	&	2,16\%	&	55	&	0	&	55	&	20	\\
java.lang.IndexOutOfBoundsException	&	62	&	9,70\%	&	166	&	2,76\%	&	53	&	0	&	93	&	18	\\
java.lang.NoSuchMethodError	&	54	&	8,45\%	&	80	&	1,33\%	&	10	&	0	&	56	&	14	\\
java.util.ConcurrentModificationException	&	43	&	6,73\%	&	65	&	1,08\%	&	5	&	0	&	46	&	13	\\
    \hline
  \end{tabular}
\caption{Root Exceptions occurrences and popularity in repositories hosted in Google Code (GC) and GitHub(GH).}
\label{tab:topten}
\end{table*}

%\begin{figure}
%\centering
%\includegraphics[width=\hsize]{top_exceptios_android_new2.pdf}
%\includegraphics[width=\hsize]{top_exceptions_android_new}
%\caption{Top exceptions in Android repositories.}
%\label{fig:androidsignaler}
%\end{figure}
 
We can observe that most of the exceptions on this list are implicitly thrown by the
 runtime environment due to programming mistakes  (e.g., out-of-bounds array index, division-by-zero, access to a null reference)
 or resource limitation (e.g., OutOfMemoryError). 
From this set the java.lang.NullPointerException was the most reported root cause (27,71\% ). 
If we consider the frequencly of NullPointerException 
across projects, we can observe that 51,96\% of all projects reported at least one exception stack 
trace on which the NullPoiterException was the root cause.

 The NullPointerExceptions are mainly signaled inside the applicaiton code and the Android platform,
 although we could also find NullPointerExceptions being signaled by third-party libraries. 
Regarding reusable code, there is no consensus whether it is a good or bad practice to 
re-throw a NullPointerException. Some prefer to encapsulate such an exception on
IllegalArgumentException, while others~\cite{bloch2008effective} argue that the
NullPointerException makes the cause of the problem explicit and hence 
should not be wrapped.

The high prevalence of NullPointerExceptions is aligned with the findings of other 
works~\cite{kim2013predicting,fraser20131600,csallner2004jcrasher}. For instance, Sunghun et
al.~\cite{kim2013predicting} showed that in Eclipse bug report system 38\% the bugs 
related to exception handling were caused by NullPointerException; other works on robustness 
testing~\cite{maji2012empirical,csallner2004jcrasher} showed that most of the automatically 
detected bugs were due to NullPointerExceptions and exceptions implicitly-signaled by Java 
environment due to programming mistakes or resource limitations
 (as the ones found in this study).

\emph{\textbf{The prevalence of programming mistakes on stack traces.}} One way of getting a broader view of the prevalence~\footnote{The prevalence evaluates the proportion of a given characteristic over a group of subjects.}  of programming mistakes on reported stack traces would be to manually inspect the code responsible for throwning every exception reported  on issues. However, inspecting the code related to 6005 stack traces can easily become infeasible.
Hence, we conducted an empirical investigation based on the following assumption: the name of the exception and its associated Javadoc 
documentaion hold enought information to pinpont a ``programming mistake".To exemplify, an instance of ArrayOutOfBoundException
 pinpoints to programming mistake which indicates that an array has been accessed with an illegal index.

To perform this empirical investigation, we selected a subset of all reported root exceptions. 
This subset was composed by the top 100 root exceptions (from a list ranked by the number of ocurrences on stacks).
This subset was representative since it contained root exceptions that were reported as the root causes of 95\% of 
all stack traces. Therefore, based on the inspection of the full names exceptions and the associated 
 Javadocs we could identify from this subset, which exceptions were related to programming mistakes.
 It is woith mentioning that  all exceptions identified as programming mistakes were exceptions defined on java.lang and java.util packages. 
After doing such analysis, we could calculate the prevalence of such exceptions on issues. In other words, we could calculate the proportion of issues mentioning the exceptions identified in this analysis as related to ``programming mistakes".

Table ~\ref{tab:causes} summarized the results. It also illustrates the number of general Java exceptions - 
whose full name does not carry the reason for the exception to be thrown.
To ensure the quality of the analysis, three independent coders classified a randomly selected
sample of 25 exception types (from the total 100) using the same list of concerns;
the resulting interrater agreement was high (96\%). We could also observe that
We can therefore assume that the exception names and Javadoc 
were enough for classifying the exception types analyzed. 

The results show that the programming mistakes associated to the most reported root causes. 
Although there is usually no proper handling for such exceptions, 
besides presenting an error message to the user and restarting the application ~\footnote{Only 
high fault tolerant systems need to provide solutions to handle them.}.  
This finding calls the attention to the following: the high number of programming errors reported 
on issues are an indication that developers may be underestimating the impact that such 
mistakes have on application robustness.

\begin{table}
  \centering
  \begin{tabular}{lr}
    \hline
    \bfseries{Cause} &  \bfseries{\% Occurrences} \\
    \hline
      Programming Mistakes &  51,96\%\\ 
      Memory Restriction   &   4,10\% \\ 
      General Exceptions   &  6,70\%\\
    \hline
 \end{tabular}
  \caption{Identifying the concerns related to root exceptions}
  \label{tab:causes}
\end{table}



\noindent \fbox{ \begin{minipage}{0.96\columnwidth} \emph{
A multitude of programming mistakes were reported as the main causes of exception stack traces.
51,96\% of all projects reported at least one exception
 stack trace on which the NullPoiterException
was the root cause.
}
\end{minipage}}

\subsection{What can the Types of Root Exceptions tell us?}
%\subsection{Exploring the Information Embedded on Exception Types}
%\subsection{The Exception Types and What They can Tell us? }

As mentioned before, using the ExceptionMiner tool in combination with manual inspections we could identify
the root exception types (i.e., RuntimeException, Error, checked Exception) as well as its origins - which were 
identified based on the package names of the signalers related to it on the stack traces (see Section ~\ref{sec:exceptionminer}).
Table~\ref{tab:typeroottab} presents the types and origins of root exceptions of all stack traces analyzed. 

We can see, from Table ~\ref{tab:typeroottab}, that contrating with the other origins, most of the 
 exceptions signaled on Android Libcore (i.e., the set of libraries reused by the Android) were 
checked exceptions. Such set comprises: org.apache.harmony, org.w3c.dom, sun.misc, 
org.apache.http, org.json, org.xml, javax. Signaling checked exceptions is considered a 
good practice (see best practice IV in Section~\ref{sec:best}) because by using checked exceptions a library can define a precise 
exception interface ~\cite{miller1997issues} to its clients.
 Since such libraries are heavily used  in several projects, such finding can be related to the library's maturity.

%SELECT COUNT(*) FROM STACKTRACESUMMARY WHERE
% repo !='android'  AND MAIN_EXTENDS LIKE 'RUNTIME%' 
%SELECT COUNT(*) FROM STACKTRACESUMMARY WHERE
%repo !='android'  AND MAIN_EXTENDS LIKE 'RUNT%' AND MAINSIGNALER_FROM like 'APP%';

\begin{table}
\centering
\begin{tabular}{lccccr}
    \hline
    \bfseries{Root Cause Type} & \bfseries{Android} & \bfseries{Libcore} & \bfseries{App} & \bfseries{Lib}  & \bfseries{All}\\
    \hline

Runtime	&	1335	&	73	&	1843	&	690  &	3894 (64,85\%)\\  %2466+854
Error	       &	 188              &	 46	&	302             &	167	           &	691 (11,51\%)	\\
Checked	&	276           &	314	&	313          &	567	           &	1358 (22,61\%)	\\
Throwable	&	0	       &	0	&	2            &	0         &	2 (0,03\%)	\\
Undefined	&	4	&	0	&	18		&	38	   &	60	(1,00\%) \\
 \hline
All		& 1  803	&	433	&	2478	&	1462	&	6005	\\
    \hline
  \end{tabular}
\caption{Types of root exceptions.}
  \label{tab:typeroottab}
\end{table}


We can also observe that most of the reported exceptions were RuntimeExceptions
(64,85\%); and most of them were signaled on methods defined on the Application 
the Android Platform or on libraries.Taking into account the results of empirical study on 
the prevalende of ``programming erros" we know that a considerable ammount 
of such exceptions, are related to the programming mistakes
as pointed out previously.

However, within this set of runtime exceptions there are also the ones that do not correspond to programming mistakes,
and according to best practice IV should be documented as part of the exception interface of libraries/framework reusable
methods.

To investigate the obedience to such practice, we firstly filtered out all the exceptions implicitly
 signaled by  runtime environment (due to programming mistakes) since these exceptions 
should not be documented on the method signature. 

Then we inspected the code each method (defined either on Android  Aplication Framework or on libraries) 
explicitly signaling a runtime exception not-related to programming mistakes.
As a result of this inspection, we could observe that only 1 method out of 118 inspected methods
 (i.e., 0,8\%) documented the explicitly thrown runtime exception in a Javadoc comment; and none of these methods
included the runtime exception  (reported on the stack) as part of the exception interface of the method (i.e., using 
throws clause on method signature). This result is aligned with the results of other study conducted by from 
Sacramento et al ~\cite{sacramento2006unchecked} which observed that the
runtime exceptions in .Net programs are most often not documented.

Such undocumented runtime exceptions represent a threat to system robustness, specially
when such exceptions are thrown then the third party code invoked inside the application 
(e.g. libraries, or framework utility code). In such cases the client usually do not have access to 
the source code. Hence in the absence of the exception documentation it is very difficult or even impossible
 for the client to design the application to deal with ``unforeseen runtime exceptions. As a consequence, the
 undocumented runtime exception may remain uncaught and lead to system crashes.

\noindent \fbox{ \begin{minipage}{0.96\columnwidth} \emph{
 Only 0,8\% of the methods documented the explicitly signaled runtime exceptions. 
}
\end{minipage}}

\subsection{What can the Exception Wrappings tell us?}
%SELECT COUNT(*) FROM STACKTRACESUMMARY WHERE
%repo !='android'  AND ROOT_EXTENDS LIKE 'CHECKED%' AND EXCEPTION_EXTENDS LIKE 'RUNTIME' 

%SELECT COUNT(*) FROM STACKTRACESUMMARY WHERE
%repo !='android'  AND ROOT_EXTENDS LIKE 'CHEC%' AND EXCEPTION_EXTENDS LIKE 'RUN%'; 

%SELECT COUNT(*) FROM STACKTRACESUMMARY WHERE
%repo !='android'  AND ROOT_EXTENDS LIKE 'CHEC%' AND EXCEPTION_EXTENDS LIKE 'RUN%'
%and SIGNALER_FROM LIKE 'LIB%'; 

 %Runtime &  Checked   & 70  / 18 & 114 /  34 &  66 /  9  &  0 /  & 19 / 19 &  29 / 6 \\
      %Runtime   &  Error   & 38  \ 8  & 57    &  50 \ 8  &  0   & 6 \ 2  &  1   /  0\\
%      Checked &  Runtime   & 12 \ 5  & 22 \ 9 & 4 &  0  & 9 \7 &  9 \ 2 \\
%      Checked & Error      & 7 \ 1 &  8 & 5  &  0  & 0 \ 1 &  3 \0 \\
 %     Error & Checked      & 4 \ 10  &  7 & 0  \ 6  &  7  & 0 \6 &  0   \ 8    \\
%      Error & Runtime     & 6 \ 2  &  13   & 1 &  1  & 0 \ 1 &  11 \ 3    \\

\begin{table*}
  \centering
  \begin{tabular}{llcccccc}
    \hline
    \bfseries{Wrapper Type}  &  \bfseries{Root Cause Type} &  \bfseries{Projects}  &  \bfseries{Occurrences} & \textsf{Android} & \textsf{Java/Libcore} & \textsf{Lib} & \textsf{App}  \\
    \hline
      
      Runtime &  Checked   & 88 & 148 &  75  &  0   & 38 &  35 \\
      Runtime   &  Error   & 46  &  67    &  58  &  0   & 8  &  1   \\      
      Checked &  Runtime   & 17  & 31 & 4 &  0  & 16 &  11 \\
      Checked & Error      & 8 &  9  & 5  &  0  &  1 &  3  \\
      Error & Checked      & 14 &  27 &  6  &  7  &  6 &   8    \\
      Error & Runtime     & 8  &  17   & 1 &  1  & 1 &  14    \\

  \hline
      %none   & Runtime   &  2360 & 359 \\
      %none  &   Checked  & 422  & 117 \\
      %none  &   Error   & 381  & 141 \\
      %none &  Undefined  &  15   & 10  \\
      %none & Throwable  &  1    & 1 \\
     %\hline
      %Runtime   & Runtime & 560  & 182 \\    
      %Checked   & Checked & 98   & 42  \\
      %Error     & Error   & 15   & 14  \\
    %\hline
  \end{tabular}
\caption{Wrappings comprising different exception types.}
\label{tab:wrappingandroid}
\end{table*}
Java is the only language that provides a hybrid exception model 
which offers three kinds of exceptions each one holding an inttended exception behavior (i.e., error, 
runtime and checked). The best practices I and II states the behavior that Error an Checked exceptions hold, which are: 
(i) Errors should not be handled inside the system since they usually represent unrecoverable conditions detected 
by the runtime environment (e.g.,  OutOfMemoryError); (ii) checked exceptions, on the other hand, should represent recoverable conditions. 

Table~\ref{tab:wrappingandroid} presents all wrappings found in this study, that
envolve different exception types (i.e., Error, Checked, Exception). We call 
such a wrapping a ``cross-type wrapping".  Some of these wrappings may reveal 
violations to best practices I and II (e.g. Error wrapping a Checked exception) as discussed next.

\emph{\textbf{Runtime wrapping Checked Exception.}} Such wrapping was 
detected on 88 projects. Inspecting the elements responsible for performing such wrapping, we could observe that
approximately  50\% of such wrappings were performed on methods defined on Android
Platform. Taking a closer look on the methods responsible for such wrappings,
 we could observe that approximately 41\% of them were performed by a single class,
 named ActivityThreat. This class is responsible for managing the life cycle of  Android Activities - 
invoking the life cycle methods (i.e. onCreate(), onPause()) for every Activity 
(window) of an Android app.
Figure ~\ref{fig:snippets} (a) presents a code snippet of one the methods of 
ActivityThreat,  the one responsible for invoking the Activitiy's onCreate method. 
As we can see from lines 4-8, in case any exception is thrown in the context of such try-catch block, 
it is wrapped in a general Runtime exception and re-thrown.

%\begin{table}
%\centering
%\begin{tabular}{lll}
%   \hline
% \bfseries{Signaler class} &  \bfseries{Wrapper Type} & \bfseries{Ocurrences} \\
%    \hline
%android.app.ActivityThread & java.lang.RuntimeException & 61\\
%android.view.LayoutInflater & android.view.InflateException &  7 \\
%android.os.AsyncTask & java.lang.RuntimeException &  7\\
%\hline
%  \end{tabular}
%\caption{Top 3 Runtime-Cheked wrappers.}
%\label{tab:wrapping01}
%\end{table}

Inspectioning the source code, of the methods involved in this kind of wrapping,
revealed an unexpected fragility: a checked exception thrown by a native method and not
declared on the exception interface of these methods signaling them. Such native method 
was defined on the Android Platform -  which uses Java Native Invocation (JNI) to access 
native C/C++ code. 

The code snippet in Figure ~\ref{fig:snippets} (d) illustrates this fragility.
 The java/lang/Class declares a native method named getDeclaredMethods. 
The Java-side declaration of of this method does not have any throws clause, 
leading programmers and the compiler to think that no checked exceptions can be thrown.
 However, the C-code implementation did throw a "checked exception" NoSuchMethodException, 
violating the declaration. The Java compiler, cannot detect this violation because it does 
not perform static exception checking on native methods. This type of bug is hard to diagnose
because the developer usualy do not have access to the native implementations. 
Consequently, since it is not expected by the programmer, when such method throws 
this exception, such undocumented exception may remain
uncaught and cause the app to crash, or may be mistakenly handled by subsumption - 
The exception stack traces reporting this scenario is actually a real bug of Android 
Gingerbread version (which still accounts for 13.6\% of devices running Android).

Among the Android projects on which this exception stack trace was reported we can cite:
PageTurner (206 stars, 130 forks, 1184 commits), ActionBarSherlock (6,041 stars, 
3,436 forks, and 1479 commints), otto (1,618 stars,	342 forks, 	177 commints).

\noindent \fbox{ \begin{minipage}{0.96\columnwidth} \emph{
An unexpected fragility was detected: a checked exception being thown and not specified on 
on the ``exception interface" of the signaler methods.
}
\end{minipage}}

\emph{\textbf{Runtime Exception wrapping Error.}} We could find  64 exception stack traces 
on 46 projects on which an Error was wrapped in a runtime exception.
Manually inspecting each exception stack trace, we could observe that 44% of the wrappings were performed 
by android.os.AsyncTask. This class is responsible for dealing with asynchronous tasks in Android.
The code snippet is illustrated in Figure ~ref{wrappings} (c) shows that any instance of Throwable signaled in the context of an asynchronous 
task is converted in to a runtime and re-thrown.  Table ~\ref{tab:exampeswrap} exemplifies some of such wrappings.
Such wrapping masks the unrecoverable exception in a general excepion - doing so  that can be mistakenly handled

\begin{table}
\centering

 %\begin{tabular}{|p{7.9cm} p{0.1cm}|}
\begin{tabular}{ll}
    \hline
 id & \bfseries{Runtime-Error Wrapping Examples}    \\  %\bfseries{\#}
    \hline
1 & java.lang.RuntimeException - java.lang.OutOfMemoryError  \\ %30
2 &java.lang.RuntimeException - java.lang.NoClassDefFoundError \\ %6
3 &java.lang.RuntimeException - java.lang.UnsatisfiedLinkError)  \\ %5
4& java.lang.RuntimeException -  java.lang.StackOverflowError)   \\ %4
\hline
 & \bfseries{Checked-Runtime Wrapping Examples}   \\
 \hline
5& ...android.robospice.CacheSavingException - java.lang.ClassCastException   \\ %6
6&java.lang.reflect.InvocationTargetException - java.lang.NullPointerException    \\ %3
7&java.lang.reflect.InvocationTargetException - ...ResourcesdNotFoundException  \\ %2
8&java.sql.SQLException - android.database.sqlite.SQLiteDiskIOException   \\ %2
 \hline
& \bfseries{Checked-Error Wrapping Examples}  \\
 \hline
9&java.lang.reflect.InvocationTargetException - java.lang.OutOfMemoryError  \\ %5
10&java.lang.Exception - java.lang.OutOfMemoryError   \\ %1
11&java.lang.reflect.InvocationTargetException - java.lang.NoSuchMethodError 	 \\ %1
12&java.lang.reflect.InvocationTargetException - java.lang.UnsatisfiedLinkError	 \\ %1
\hline
& \bfseries{Error-Checked Wrapping Examples}  \\
 \hline
13&java.lang.NoClassDefFoundError - java.lang.ClassNotFoundException   \\ %4
14&java.lang.AssertionError - javax.crypto.ShortBufferException)   \\ %3
\hline
& \bfseries{Error-Runtime Wrapping Examples}    \\
 \hline
15&java.lang.ExceptionInInitializerError - java.lang.NullPointerException   \\ %9
16&java.lang.ExceptionInInitializerError - java.lang.IllegalArgumentException 	 \\ %2
 \hline
  \end{tabular}
\caption{Examples of Cross-type wrappings}
\label{tab:exampeswrap}
\end{table}


\emph{\textbf{Checked wrapping Runtime Exception.}} Manually inspecting the stack 
traces we could observe that such wrappings were performed either 
by RoboSpice (an android library that supports the creation of asynchronous long running 
tasks, which has 1.682 stars and 367 forks in GitHub) or by the reflection Java library (used by
methods defined in Android, Application and library classes). 

\emph{\textbf{Checked Exception wrapping Error.}} Almost all of these wrappings
 were also caused by the reflection library used by Android applications. The methods responsible for the wrappings
were also native methods written in C. Table~\ref{tab:exampleswrap} illustrates
some oth these wrappings some of them are masking an OutOfMemoryError
into a checked exception.

\emph{\textbf{Error wrapping Checked Exception.}} These wrappings were performed
either by native methods defined by java.lang.Class (e.g., getDeclaredFields, getDeclaredConstructors) 
or methods from javax.crypto package. Table~\ref{tab:exampleswrap} illustrates
the exception types involved in such wrappings.

\emph{\textbf{Error wrapping Runtime.}} After manually inspecting the code associated to such wrappings 
we discovered that all of them were caused by static initializers. If any exception is thrown in the context of a static initializer (i.e., static block) 
it is converted into an ExceptionInitializerError on the point where the class is first used. Table ~\ref{exampleswrap} illustrates
the exception types involved in such wrappings.

We could also observe that some stack traces included several intermediate cross-type wrappings.
One interesting example was the following: Runtime-Checked-Runtime-Checked-Runtime-Checked-Runtime.
Although some of these wrappings may be a result of design decision
the mis-use of exception wrapppings may make the exception handling 
code more complex (e.g., the multiple wrappings) and error-prone,
 and lead to what we call ``exception confusion problem"
To illustrate this problem we can use one of the wrappings discussed above.
When the developer is confronted with a checked exception, the designer of the API is telling him 
to handle the exceptional condition. However we could observe that in some cases the 
checked exception wrapped an OutOfMemoryError, which represent resource deficiency detected 
by the runtime environment which make impossible the program to recover. 
Hence, trying to handle this exception may lead the program to an unpredictable state.

\noindent \fbox{ \begin{minipage}{0.96\columnwidth} \emph{
Some of the detected cross-type exception wrappings points to a potential ``exception confusion problem".
To illustrate: a checked exception wrapping an OutOfMemoryError; and the multiple wrapping Runtime-Checked-Runtime-Checked-Runtime-Checked-Runtime.
}
\end{minipage}}


\section{Further Discussions}
\label{sec:disc}

\begin{figure*} \centering \includegraphics[scale=0.55]{examples_new2.png}
\caption{Code snippets illustrating fragilities on the exception-related code} \label{fig:snippets} \end{figure*}

 "Everybody hates thinking about exceptions, because they’re not supposed to happen"
  Brian Foote


\subsection{On the need of rescues to the almost infeasible task of preventing uncaught exceptions}
In this study we could observe undocumented runtime exceptions thrown by third party code,
and even undocumented checked exception thrown by a JNI interface.
Such undocumented exceptions make difficult, and most of the times infeasible
for the client code to protect against `unforeseen" situations that may happen 
while calling a library code.

One may think that the solution for the uncaught exceptions may be to define a general handler, 
which is responsible for handling any exception that is not
adequately handled inside the applications. Although this 
solution may prevent  the system of abruptly crashing,
 such general handler will not have enough
contextual information to adequately handle the exception, 
and only tasks possible are: to present a message to the user
 and restart the application.

However, such handler cannot replace a carefully designed exception 
handling policy, which can hardly be designed in the absence of 
third-party documentation on the exceptions that
may the thrown by it.

On the other hand, documenting runtime exceptions is a tedious and error prone task, to help developers
mitigate this problem tools should be developed to automate the documentation of runtime exceptions
scraping from library code, few solutions in this directions have been proposed so far ~\cite{van2005combining}. 

\subsection{On the null pointer problem}
The null references was firstly introduced by Tony Hoare in ALGOL W, which after some years he called his “one-billion-dollar mistake” ~\cite{hoare}:

\emph{``I call it my billion-dollar mistake. It was the invention of the null reference in 1965 [...] I couldn’t resist the temptation to put 
in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system 
crashes, which have probably caused a billion dollars of pain and damage in the last forty year."}

In this sudy, the null references were, infact, responsible for several reported application errors - providing more evidences to Hoare's speach.
This observation emphasizes the importance of solutions to avoid NullPointerExceptions, such as:
(i) lightweight intra-method null pointer analysis supported by Java8 @Nullable annotations ~\footnote{The @Nullable annotations are used by tools such as FindBugs, Eclipse, NetBeans, IntelliJ to detect potential 
null pointer dereferences at compile time. In April/2014 the Android Studio 0.5.5 was 
released with support to these annotations};
(ii) inter-method null pointer analysis tools such as the one proposed by Nanda and Sinha ~\cite{nanda2009accurate};
or (iii) whether language designs which avoid null pointers, such 
as Monads ~\cite{Walde95} (i.e., used in functional languages for values that may not be available 
or computations that may fail) could improve the robustness of Java programs. 


\subsection{The exception handling confusion problem}
When (mis)applied, the exception wrapping can make the exception-related code
 more complex and lead to what we call an \emph{exception handling confusion problem}.
Such problem can lead the program to an unpredictable state in the presence of exceptions,
as illustrated by the scenario on which a checked exception wrapped an OutOfMemoryError. 
Currently there is no way of enforcing Java exception type conventions during program development.
Hence, further investigation is needed on finding ways to help developers in dealing with such
 problem, either preventing odd wrappings or enabling the developer to better deal with them or even
researches on the real usefulness of Java hybrid exception model. 

%The cross-type wrappings detected in this study points to the fact that: (1) exception 
%wrappings may prevent exception types from being used according to its initial purpose
%(e.g, Errors should represent situations that should not be handled); and (2) may have been
% used to bypass the language restrictions imposed by checked exceptions  (e.g,
% checked exceptions may be wrapped in runtime exceptions).



\section{Threats to Validity}
\label{sec:threats}

\noindent\emph{Internal Validity.} We used a heuristics-based parser to mine
exceptions from issues.  Our parsing strategy was conservative by default; for
example, we only considered exception names using a fully qualified class name
as valid exception identifiers, while, in many cases, developers use the
exception name in issue description. Conservative parsing may minimize false
positives, which was our initial target, but also tends to increase false
negatives, which means that some cases may have not been identified as
exceptions or stack traces. Our limited manual inspection did not reveal such
cases. Moreover, in this study we manually classified the exceptions 
related to programming mistakes. To ensure the quality of the analysis, 
we calculated the interrater agreement after three independent 
coders classified a randomly selected sample (of 25 exception 
types from the total 100); the interater agreement was high (96\%). 
Another threat relates to the fact that parts of our analysis 
are based on the availability of stack traces on issues on Github and Googlecode. 
In using these datasets, we make an underlying assumption: the stack traces reported on issues are 
representative of valid crash information of the applications. 
One way to mitigate such threat would be to access to the full 
set of crash data per application. Although some services exist 
to collect crash data from mobile applications ~\cite{BugSe14,BugSn14,Googl14,Acra14},
they do not provide open access to the crash reports of their client applications.
In our study, we mitigated this threat by manually inspecting
the source code associated to a subset of the reported exception stack traces.
Such subset comprise the stack traces related to the main findings 
of the study (e.g., `ùndocumented runtime and checked exceptions",
and cross-type wrappings").

\noindent\emph{External Validity.} Our work use GHTorrent dataset. Although 
comprehensive and extensive is not an exact replica of Github. 
However, the results of this study does not depent on the analysis of
a complete Github dataset. Instead, we limited out analysis to a subset of
existing open-source Android projects availabe on GitHub and Googlecode.
Moreover, we are aware that the reported exceptions 
for commercial apps can be different from the ones found in this study, and that
this subset is a small percentage of existing apps.
Such threats to validity are similar to the ones imposed on the other empirical studies 
which also used free or open-source Android apps ~\cite{Linar13,McDon13,ahimed}.
Moreover,  several exception stack traces that support the findings of this study
refered to exceptions comming from methods defined on Android Application Framework
and third-party libraries.  Additionaly,  the ``fragilities" observed in this study are due to
characteristics of Java exception model, which can impose challenges 
the robustness of not ony to Android apps but also to other systems
 based on the same exception model. 


\section{Related Work}
\label{sec:rele}

In this section, we present work that is related to the present paper, divided into
three categories: i) papers that use the information available on stack traces;
ii) empirical studies on the usage of Java exceptions and its fault proneness;
and iii) tools to extract stack traces information from natural language artifacts
(e.g., issues and emails).
%, and iv) empirical studies involving Android apps.


\textit{Empirical studies using Android apps.} Ruiz et al.~\cite{Ruiz12}
investigated the degree of reuse across applications in Android Market, the
study showed that almost 23\% of the classes inherited from a base class in the
Android API, and that 217 mobile apps were reused completely by another mobile
app. Pathak et al.~\cite{Patha11} analyzed bug reports and developers
discussions of Android platform and found out that approximately 20\% of
energy-related bugs in Android occurred after an OS update. McDonnell et
al.~\cite{McDon13} conducted a case study of the co-evolution behavior of
Android API and 10 dependent applications using the version history data found
in github. The study found that approximately 25\% of all methods in the client
code used the Android API, and that the methods reusing fast-evolving APIs were
more defect prone then others. Vásquez et al.~\cite{Linar13} analyzed
approximately 7K free Android apps and observed that the last successful apps
used Android APIs that were on average 300\% more change-prone than the APIs
used by the most successful apps. Pingyu and Elbaum~\cite{Zhang12} analyzed bug
reports of 5 Android applications an observed that 29\% had to do with poor
exceptional handling code. Our work differs from the others as it aims at
distilling the information of bug reports describing uncaught exceptions created
for mobile applications in Github, in order to get a first view
of what is causing the crashes across applications available and what the
characteristics of the stack traces can tell us about the exception structure of
those applications.

\textit{Extracting Stack Traces from natural language artifacts.} 
%Currently, many
%software vendors embed automatic crash reporting tools in their software
%systems. Moreover, third party crash collection services exist, most of them 
%targeted for applications run on mobile phones~\cite{BugSe14,BugSn14,Googl14,Acra14}.
Apart from bug reports, stack traces can be embedded in other forms of
communication between developers, such as discussion logs and emails.
Being intermixed with text makes the accurate extraction of stacktraces 
an involved process.
Infozilla~\cite{bettenburg2008extracting}
is based on a set of regular expressions that extract a set of frames
related to a stack trace. The main limitation of this solution is that it is not
able to extract stack traces embedded on verbose log files (i.e., on which we
can find log text mixed with exception frames). Bacchelli
et al.~\cite{bacchelli2012content} propose a solution to recognize stack trace frames
from development emails and relate it to code artifacts (i.e. classes) mentioned
on the stack trace. In addition to those tools, ExceptionMiner is able to 
both extract stack traces from natural language artifacts and to 
classify them in a set of predefined categories.

\textit{Analysis and Use of Stack Trace Information.} Several works have
investigated the use of stack trace information to support bug classification
and clustering~\cite{wang2013improving, kim2011crash, dhaliwal2011classifying},
fault-proneness prediction models~\cite{kim2013predicting} and even automated
bug fixing tools~\cite{sinha2009fault}. Kim et al.~\cite{kim2011crash} use an
aggregated form of multiple stack traces available in crash reports to detect
duplicate crash reports and to predict if a given crash will be fixed. Dhaliwal
et al.~\cite{dhaliwal2011classifying} proposed a crash grouping approach that
can reduce bug fixing time in approximately 5\%. Wang et
al.~\cite{wang2013improving} propose an approach to identify correlated crash
types and describe a fault localization method to locate and rank files related
to the bug described on a stack trace. Schroter et al.~\cite{schroter2010stack}
conducted an empirical study on the usefulness of stack traces for bug fixing
and showed that developers fixed the bugs faster when failing stack traces were
included on bug issues.  In a similar study, Bettenburg et
al.~\cite{bettenburg2008makes} identify stack traces as the second most stack
trace feature for developers.  Sinha et al.~\cite{sinha2009fault} proposed an
approach that uses stack traces to guide a dataflow analysis for locating and
repairing faults that are caused by the implicitly signaled exceptions. Kim
at al.~\cite{kim2013predicting} proposed an approach to predict the
crash-proneness of methods based information extracted from stack traces and
methods' bytecode operations.  They observed that most of the stack traces were
related to NullPointerException and other implicitly thrown exceptions had
the higher prevalence on the analyzed set of stacks.

\textit{Detecting Faults on Java Exception-Related Code.} 
Cabral and Marques~\cite{cabral2007exception} analyzed the
source-code of 32 open-source systems, both for Java and .NET. They
observed that the actions inside handlers were very simple (e.g., logging and present a
message to the user). Reimer and Srinivasan~\cite{reimer2003analyzing} listed a
set of bad practices on exception handling that hinder software maintainability
and robustness, based on their experience with Java enterprise applications.
Our work differs from those


Some tools ~\cite{Robil00}~\cite{coelho2008assessing} have ben proposed 
to employ dataflow analysis to find the propagation paths of checked and unchecked 
exception types. The main limitation of all static analysis tools is the number of false 
positives inherent to static analysis solutions, which can lead to extremely high number 
of exception flows, specially if considering Java Environment exceptions and exceptions 
signaled from libraries. Moreover, such also have limited support some libraries (e.g., Java Reflection).
Our owrk


\enlargethispage{-2\baselineskip}

\section{Conclusion}
\label{sec:conc}

In this paper we present an exploratory study in which we mined the stack 
traces embedded in all issues defined in 482 Android projects hosted in Github and 
157 projects hosted in Google Code. Overall it included 6,005 exception stack traces.
In this study, the information extracted from stack traces was used in combination 
with source code and bytecode analysis to identify common characteristics of exception 
stack traces and pin-point fragilities on the exception-related code. 
We call ``fragilities" characteristics on the exception-related code that favor the introduction
of  uncaught exceptions and unintended handling - which can contribute to 
degrade the robustness of applications.
Some fragilities consistently detected in this study were: 
(i) an abundance of NullPointerExceptions - it was mentioned as the root exception in approximately 
50\% of the analyzed projects. 
(ii) undocumented runtime exceptions thrown by third party code,
(iii) undocumented checked exceptions thrown by JNI interface,
(iv) unexpected exception wrappings (e.g., Errors being wrapped in checked exceptions) 
revealing that Java hybrid exception model is not fully used according to its purpose.
As we can see, such fragilities can negatively affect not only the robustness of Android application 
but also the robustness of any Java-based application. 
Our results calls the attention for the need of tool and language support to help 
developers when dealing with such fragilities.

 

%Nowadays many software vendors embed automatic crash reporting tools in their
%software systems. Hence, whenever a software crashes this tool sends a detailed
%crash report to its vendors. Moreover, we can also find third party software
%solutions specialized in bug reporting for different kinds of systems specially
%for the increasing marked of mobile apps~\cite{BugSe14,BugSn14,Googl14,Acra14}.
%There is plenty of information to be mined...


\section*{Acknowledgment} This work is partially supported by: CNPq -- Proc.
484209/2013-2 and the NWO TestRoots project (639.022.314).


\bibliographystyle{IEEEtran}
\bibliography{android-stacks}

% that's all folks
\end{document}


